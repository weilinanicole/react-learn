<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>React day1</title>
</head>
<body>
	<script type="text/javascript">
		/**
		Vue与React的异同点
		  React和Vue都是很优秀的框架，它们之间的相似之处多过不同之处，并且大部分的优秀功能是相通的，核心在于封装dom操作，专注视图层的轻量级框架
		相同点：
	 		1.用虚拟DOM实现快速渲染，提升性能
			2.语法简单的轻量级MVVM框架
			3.同时支持服务端客户端渲染
			4.生态优良，各种打包工具，路由，，代码分割，数据管理，swiper，echart全家桶

		异同点： 
			1.react适配多端（web页面，客户端页面）
			2.vue生态圈越来越强大，构建强大的应用也不是问题
			3.公司选啥你选啥，哪个用的爽选哪个
		了解虚拟DOM，JSX
		*/
		/**
		React脚手架工具: create-react-app
		React: react核心库
		React-dom: reactDom库
		React-scripts: 打包构建脚本
		
		React生命周期：
			constructor		构造函数

			componentWillMount 组件挂载之前	 === beforeMount
			componentDidMount	 组件挂载完成	 === mounted
			
			shouldComponentUpdate	组件是否需要更新
			componentWillUpdate 组件更新之前 === beforeUpdate
			componentDidUpdate	组件更新完成 === updated

			componentWillUnmount	组件销毁之前 === beforeDestory

			componentWillReceiveProps	组件即将接受props
			
		高性能组件:
			shouldComponentUpdate	组件是否需要更新,根据返回值为true或false判断是否需要刷新页面
			在浏览器->more tools->rendering里勾选Paing flashing可以高亮页面重绘的部分
			
			PureComponent		高性能组件，当props或state的引用没有改变时不会触发更新
			数组的深拷贝
				let arr2 = [...arr1];
			对象的深拷贝
				let obj2 = {...obj1};
				let obj2 = object.assign({}, obj1);
			强制刷新
				this.forceUpdate();	
		refs 与 findDOMNode：
			ref功能同vue中的ref，直接获取dom元素或者组件实例
			findDOMNode操作组件的ref，获取组件render的dom
		路由:
			三个依赖：
				react-route = react-route-dom + react-route-native
			纯组件：不依赖内部state，纯展示使用，配合props,
			两种模式：
				browserHistory,注意处理404 和 hashHistory
			几个组件：
				BrowserRouter	选择使用哪种模式
				Route		配置路由
				Link		跳转路由
				NavLink		特殊的link，会在选中的时候会切换active状态，配置activeClassName
				Switch		显示匹配的第一个路由
				Redirect 	重定向当前路由
			路由组件：传递的prps, match+location
			路由传参：
				path的两种方式：字符串和对象

				pathname: '', 路径
				data: 任意数据
			路径语法：
				<Route path="/hello/:name">         // 匹配 /hello/michael 和 /hello/ryan
				<Route path="/hello/:name?">       // 匹配 /hello, /hello/michael 和 /hello/ryan
				<Route path="/files/*.*">           // 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg
			关键字：
				exact 精准匹配
				replace 替换当前路径，表现就是返回的时候直接返回上上一层
		

			代码分割：	
				意义和如何用webpack实现
			组件外部调用路由导航

		高阶函数：
			在函数的基础上，再做一层封装，抽离一些公共逻辑
			接收一个函数，输出一个函数
					
		*/
	</script>
	<script>
		window.localStorage.setItem('name', '刘畅');
		function eat(){
			let name = window.localStorage.getName('name');
			console.log(`${name}要去吃饭`)
		}
		function wash(){
			let name = window.localStorage.getName('name');
			console.log(`${name}要去洗澡`)
		}
		eat();
		wash();

		// 高阶函数的写法
		function eat(name){
   			console.log(`${name}要去吃饭`)
		}
		function wash(name){
			console.log(`${name}要去洗澡`)
		}
		function getName(func){
			let name = window.localStorage.getName('name');
			return ()=>{
				func(name);
			}
		}
		let eat = getName(eat);
		let wash = getName(wash);




		let wrapWash = getName(wash);
		wrapEat();
		wrapWash();
	</script>
</body>
</html>